\documentclass[12pt]{article}

% This first part of the file is called the PREAMBLE. It includes
% customizations and command definitions. The preamble is everything
% between \documentclass and \begin{document}.

\usepackage[margin=1in]{geometry}  % set the margins to 1in on all sides
\usepackage{graphicx}              % to include figures
\usepackage{amsmath,bm}            % great math stuff
\usepackage{amsfonts}              % for blackboard bold, etc
\usepackage{amsthm}                % better theorem environments
\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage[]{algorithm2e}
\usepackage{parskip} 			   % no paragraph indentation

\usetikzlibrary{arrows,automata}


% various theorems, numbered by section

\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{conj}[thm]{Conjecture}

\DeclareMathOperator{\id}{id}

\newcommand{\bd}[1]{\mathbf{#1}}  % for bolding symbols
\newcommand{\RR}{\mathbb{R}}      % for Real numbers
\newcommand{\ZZ}{\mathbb{Z}}      % for Integers
\newcommand{\col}[1]{\left[\begin{matrix} #1 \end{matrix} \right]}
\newcommand{\comb}[2]{\binom{#1^2 + #2^2}{#1+#2}}

\lstset{ % General setup for the package
    language={[LaTeX]TeX},
    basicstyle=\footnotesize\sffamily,
    tabsize=4,
    columns=fixed,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue},
    xleftmargin=.1\textwidth,
    xrightmargin=.1\textwidth
}

\begin{document}

\nocite{*}


\title{Randomized Algorithms \\
       Assignment 2}

\author{Viktor Hansen \& Simon Rueskov Schleicher}

\maketitle

\begin{abstract}
  This is the second weekly assignment for the Randomized Algorithms course offered at The Department of Computer Science, Uni. Copenhagen.
\end{abstract}

\pagebreak

\section*{Problems}

\subsection*{2.1}
We prove by induction over k that for any deterministic evaluation algorithm, there are instances of $T_{d,k}$ that forces the algorithm to read the values on all $d^{2k}$ leaves and the last leaf read determines whether the root is 1 or 0.\\
\\
Base step: for k=0 we only have one leaf, so any deterministic evaluation algorithm has to read them all. Furthermore that leaf is the root, so it determines whether the root is 1 or 0.\\
\\
Induction step: We assume it holds for any tree with size $k$, and need to show that it holds for any tree of size $k+1$. For a tree of size $k+1$, we have at the top a root that is an AND-note. Below that we have two OR-nodes, and below that we have 4 trees of size k. Since a deterministic evaluation algorithm looks at the nodes in a deterministic order, it also looks at the nodes in each of the subtrees in a specific order, and we can use the induction hypothesis.\\
There has to be one of the subtrees that are the first to get its last node inspected. We use the induction hypothesis and set the last node inspected in that subtree in the way that makes the root of that subtree 0. Since the parent to that root is an OR-node, we don't know yet whether it will be 1 or 0.\\
The 2nd subtree to get its last node inspected has 2 possibilities: Its root either shares a parent with the subtree we have already evaluated or it doesn't.\\
In the case where it shares a parent, we set the last node inspected in the way that makes the root 1. The parent OR-node can now look at a 1 and a 0, so the result is 1, but then we don't know the result of the AND-node in the root of the whole tree. We set the last node in the 3rd subtree to get fully evaluated in such a way that the root of that subtree is 0, and we have to inspect the 4th subtree. We can set the last node in the 4th subtree both so the root of the whole tree is 0 and so the root of the whole tree is 1.
In the case, where the 2nd subtree fully evaluated does not share a parent with the first, we set the last node in that subtree, so the root of the tree is 0, and we can't evaluate the parent OR-node. The 3rd subtree fully evaluated now either shares a parent with the first or the second subtree fully evaluated. We set the last node in the 3rd subtree in such a way that the root is 1, and we then have to also fully evaluate the 4th subtree before we can evaluate the root of the whole tree. Depending what we set the last node inspected in the 4th subtree, the root of the whole tree can both result in 0 or 1.\\
And we're done.

\subsection*{3.1}
Let $X$ be the number of empty bins after $m$ balls and $X_i$ be 1 if bin $i$ is empty after $m$ balls and 0 otherwise for $0\leq i\leq n$. For $X_i$ to be empty after m balls, we need all the m balls to land in a different bin, so we have $Pr[X_i]=\left(1-\frac{1}{n}\right)^m$ and $$E[X]=\Sigma_{i=0}^nE[X_i]=\Sigma_{i=0}^nPr[X_i]=\Sigma_{i=0}^n\left(1-\frac{1}{n}\right)^m=n\left(1-\frac{1}{n}\right)^m$$
For $m=n$ we get $$E[X]=n\left(1-\frac{1}{n}\right)^n\approx\frac{n}{e}$$

\subsection*{3.3(a)}
Let $X$ be the number of memory modules that has received exactly 1 memory request after $n$ memory requests has been sent and $X_i$ be 1 if memory module $i$ has received exactly 1 memory request after $n$ memory requests has been sent and 0 otherwise for $0\leq i\leq n$. We have $Pr[X_i]={n\choose 1}\left(\frac{1}{n}\right)^1\left(1-\frac{1}{n}\right)^{n-1}=\left(1-\frac{1}{n}\right)^{n-1}$.\\
Let $Y$ be the number of memory modules that has received exactly 2 memory request after $n$ memory requests has been sent and $Y_i$ be 1 if memory module $i$ has received exactly 2 memory request after $n$ memory requests has been sent and 0 otherwise for $0\leq i\leq n$. We have $Pr[Y_i]={n\choose 2}\left(\frac{1}{n}\right)^2\left(1-\frac{1}{n}\right)^{n-2}={n\choose 2}\frac{1}{n^2}\left(1-\frac{1}{n}\right)^{n-2}$.
Let $Z$ be the number of processors whose requests are satisfied. We have \begin{align*}E[Z]&=E[X]+2E[Y]=\left(\Sigma_{i=0}^nE[X_i]\right)+2\Sigma_{i=0}^nE[Y_i]=\left(\Sigma_{i=0}^nPr[X_i]\right)+2\Sigma_{i=0}^nPr[Y_i]\\&=\left(\Sigma_{i=0}^n\left(1-\frac{1}{n}\right)^{n-1}\right)+2\Sigma_{i=0}^n{n\choose 2}\frac{1}{n^2}\left(1-\frac{1}{n}\right)^{n-2}\\&=n\left(1-\frac{1}{n}\right)^{n-1}+2n\frac{n(n-1)}{2}\frac{1}{n^2}\left(1-\frac{1}{n}\right)^{n-2}=\frac{n}{1-\frac{1}{n}}\left(1-\frac{1}{n}\right)^n+(n-1)\left(1-\frac{1}{n}\right)^{n-2}\\&=\frac{n-1}{\left(1-\frac{1}{n}\right)^2}\left(1-\frac{1}{n}\right)^n+\frac{n-1}{\left(1-\frac{1}{n}\right)^2}\left(1-\frac{1}{n}\right)^n\approx\frac{2e(n-1)}{\left(\frac{n-1}{n}\right)^2}=\frac{2en^2}{n-1}\end{align*}
This is around $2en$, which is of course impossible (we can satisfy more processor than are available), so we must have made a mistake somewhere.

\pagebreak

\section*{Summary}


\end{document}
